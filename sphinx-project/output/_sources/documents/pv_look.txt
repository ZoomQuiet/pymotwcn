PV_LOOK
=======

:Author: vbarter <caijunjie@baidu.com>

.. contents::
.. sectnum::

当前由于服务器数量众多，查看各个服务器apache、ui、transmit等流量实时变化比较麻烦，一般的做法是抽样检查，本工具能够显示各个模块的流量变化，能够辅助网络检查。

基本介绍
--------

本工具包含三个文件：

.. code::
        
    servers ：服务器列表
    pv_look.py ：浏览查看脚本，部署在服务器端（中控）
    get_pv.py ：流量获取脚本，部署在客户端（远程服务器）

servers中配置需要监控的服务器列表。
get_pv.py分发到需要监控的服务器的apache目录中

.. note::
    
    目前get_pv.py可以直接针对apache日志的access_log文件进行分析，所以建议建立apache小时文件的软链接。针对ui、transmit等日志的监控，需要修改代码第19行的日志文件名。

运行方法
~~~~~~~~
::

    python ./pv_look.py


依赖关系
~~~~~~~~

.. code:: python
    
    import paramiko as ssh
    import threading
    import signal
    import sys
    from time import *
    from threading import  Thread  
    import curses
    import copy


paramiko模块可以基于SSH2协议与远程服务器进行通信。signal模块用于处理系统信号量，如ctrl+c中断。curses模块用于构建交互式的文本模式程序。
安装paramiko和curses的方法：

::

   easy_install paramiko
   easy_install curses

下载方法
~~~~~~~~

::

   wget ftp://tc-nsop-test1.tc.baidu.com//home/caijunjie/share/pv_look.tar.gz 
 

脚本基本逻辑
-------------

get_pv.py
~~~~~~~~~~~~~

模拟 ``tail -f`` 功能。

.. code:: python

    if __name__ == "__main__" :

        fi = "access_log"
        file = open(fi,"r")
        # 指向文件末尾
        st = os.stat(fi)
        st_size = st[6]
        file.seek(st_size)
        while 1:
            where = file.tell()
            content = file.readlines()
            if not content:
                sleep(1)
                file.seek(where)
            else:
                if len(content) < 10:
                    continue
                myTime = strftime('%H:%M:%S', localtime())
                os.system("echo %s:%s" % (myTime,len(content)))

pv_look.py
~~~~~~~~~~

支持多线程模式监控服务器的日志流量，并采用交互式文本显示相关信息。

.. code:: python

    class Ssh(Thread):

        # 初始化函数，接收三个参数，pos:服务器id，host:服务器名:,username:登陆名
        def __init__(self,pos,host,username):
            self.host = host
            # x和y为交互式文本界面的坐标，x为纵轴，y为横轴。
            self.x = gb.row
            self.y = gb.col
            #print "%s\t%s\t%s" % (self.host,self.x,self.y)
            gb.row += 1
            self.username = username
            self.client = ssh.SSHClient()
            self.client.load_system_host_keys()

        def get_datas(self):
            # 启动远程服务器的get_pv.py脚本，并通过stdout channel返回结果
            self.stdin, self.stdout, self.stderr = self.client.exec_command("cd apache/logs;./get_pv.py")
        
        def run(self):
            self.get_datas()
            line = self.stdout.readline()
            while line:
                # 一直有数据的话，即循环读
                #myTime = strftime('%H:%M:%S', localtime())
                #print("[%s] %s" % (self.host,line))
                str = "[%s] %s" % (self.host,line)
                # 交互式文本输出
                draw(self.host,str,self.x,self.y)
                line = self.stdout.readline()

以上为针对paramiko链接功能的多线程封装。每增加一台机器服务器的监控，即增加一个Ssh。

.. code:: python

    def draw(host,chr,x=0,y=20):
        """
        函数多线程的的输出进行了同步控制，利用了队列结构。以便达到全部服务器每秒同步刷新。
        """
        global servers
        global ss
        global average
        if host in gb.svrs:
            gb.svrs.remove(host)
            if ss.has_key(host) and len(ss[host]) != 0:
                xx,yy = ss[host].pop()
                ss[host].append((x,y))
            else:
                xx,yy = x,y
        else:
            if not ss.has_key(host):
                ss[host] = [(x,y)]
            else:
                ss[host].append((x,y))
        if len(gb.svrs) == 0:
            gb.scrn.refresh()
            gb.svrs = copy.deepcopy(servers)

        value = int(chr.split(":")[-1])         
        tag = "[-]"
        if not average.has_key(host):
            average[host] = [value]
        else:
            # 计算上升和下降策略，有优化的余地，现在取前10个数的平均值与当前值比较。
            if len(average[host]) == 10:
                if sum(average[host]) / 10 > value:
                    tag = "[DOWN]"
                elif sum(average[host]) / 10 < value:
                    tag = "[UP]"
                else:
                    tag = "[-]"
                average[host].pop()
                average[host].append(value)
            else:
                average[host].append(value)

         gb.scrn.addstr(xx,yy,chr)
         # 增加颜色显示，1 代表红色，2代表绿色
         if tag == "[UP]":
             gb.scrn.addstr(xx,yy+30,tag,curses.color_pair(1))
         if tag == "[DOWN]":
             gb.scrn.addstr(xx,yy+30,tag,curses.color_pair(1))
         if tag == "[-]":
             gb.scrn.addstr(xx,yy+30,tag,curses.color_pair(1))

draw()为交互式文本输出的核心函数。

交互式模式的关闭：

.. code:: python

    def restorescreen():
        curses.nocbreak()
        curses.echo() 
        curses.endwin()

交互式模式接收用户的按键事件：

.. code:: python
    
    def get_ch():
        # was returned as an integer (ASCII); make it a character 
        while True:
            c = gb.scrn.getch()
            c = chr(c)
            # quit?
            if c == 'q':
                return 0


TODO
----

目前该工具的使用按存在一些易用性问题，比如需要分发一个 ``get_pv.py`` 脚本来完成pv量的采集。对不同日志的监控需要修改源代码。

#. 数据获取方式优化，简化 ``get_pv.py`` 脚本运行方式。
#. 配置优化。增加可定制性。
#. 交互式模式显示优化，现在模式支持单列显示，对于服务器较多情况还支持不好，可以考虑多列。
#. 安装优化，能支持setup方式安装。

